"""
This type stub file was generated by pyright.
"""

from typing import Any

"""Utility functions and universal placeholder for ZVIC."""
def assumption(obj: Any, expected: type) -> bool:
    """
    Check if obj is an instance of expected type or any type in a union.
    Usage:
        assert assumption(a, int)
        assert assumption(b, str | float)
    """
    ...

def normalize_constraint(expr: str) -> str:
    """
    Normalize a constraint string by parsing and unparsing it via AST.
    This ensures a canonical form for expressions like '_ < 10'.
    """
    ...

class _:
    def __getattr__(self, name): # -> Self:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    
    def __call__(self, *a, **k): # -> Self:
        ...
    
    def __getitem__(self, k): # -> Self:
        ...
    
    def __setitem__(self, k, v): # -> None:
        ...
    
    def __delitem__(self, k): # -> None:
        ...
    
    def __contains__(self, item): # -> Literal[True]:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __next__(self):
        ...
    
    def __reversed__(self): # -> Iterator[Any]:
        ...
    
    def __bool__(self): # -> Literal[True]:
        ...
    
    def __len__(self): # -> Literal[0]:
        ...
    
    def __eq__(self, o) -> bool:
        ...
    
    def __ne__(self, o) -> bool:
        ...
    
    def __lt__(self, o) -> bool:
        ...
    
    def __le__(self, o) -> bool:
        ...
    
    def __gt__(self, o) -> bool:
        ...
    
    def __ge__(self, o) -> bool:
        ...
    
    def __add__(self, o): # -> Self:
        ...
    
    def __sub__(self, o): # -> Self:
        ...
    
    def __mul__(self, o): # -> Self:
        ...
    
    def __matmul__(self, o): # -> Self:
        ...
    
    def __truediv__(self, o): # -> Self:
        ...
    
    def __floordiv__(self, o): # -> Self:
        ...
    
    def __mod__(self, o): # -> Self:
        ...
    
    def __divmod__(self, o): # -> tuple[Self, Self]:
        ...
    
    def __pow__(self, o, m=...): # -> Self:
        ...
    
    def __lshift__(self, o): # -> Self:
        ...
    
    def __rshift__(self, o): # -> Self:
        ...
    
    def __and__(self, o): # -> Self:
        ...
    
    def __xor__(self, o): # -> Self:
        ...
    
    def __or__(self, o): # -> Self:
        ...
    
    def __neg__(self): # -> Self:
        ...
    
    def __pos__(self): # -> Self:
        ...
    
    def __abs__(self): # -> Self:
        ...
    
    def __invert__(self): # -> Self:
        ...
    
    def __complex__(self): # -> complex:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __float__(self): # -> float:
        ...
    
    def __index__(self): # -> Literal[0]:
        ...
    
    def __round__(self, n=...): # -> Literal[0]:
        ...
    
    def __trunc__(self): # -> Literal[0]:
        ...
    
    def __floor__(self): # -> Literal[0]:
        ...
    
    def __ceil__(self): # -> Literal[0]:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> Literal[False]:
        ...
    
    def __await__(self): # -> Generator[Self, Any, None]:
        ...
    
    def __aiter__(self): # -> Self:
        ...
    
    def __anext__(self):
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> Literal['_']:
        ...
    


_ = ...
